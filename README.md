# üìΩÔ∏è ABN Amro Tube 

A Vue.js-based application to browse TV shows from http://www.tvmaze.com/api .

## Requirements *
- Node.js (v21.6.1)
- npm (v10.2.4)
- An active internet connection (for data)

\* A warning will be issued when installing the project in lower versions, but it might still work.

## Running the application
- Install the project (`npm install`)
- Build the application (`npm run build`)
- Run the application (`npm run preview`)
- Follow the link output in the console

Obs.: [This project was bootstrapped with Vite](#keeping-scaffolding-boilerplate-templates-plugins-etc-to-a-minimum), so those steps should look familiar to those used to the tool.

### Running the unit tests
Once the project is installed (`npm install`), the command `npm test` can be issued to run the unit tests.

### No live environment
Since the ABN Amro trademark is used in this project, there is no live environment where this project is running. Were that a requirement, one just had to place the contents in the `dist` folder, generated by the `build` script, in an HTTP server.

## Development notes

### Keeping scaffolding, boilerplate templates, plugins, etc. to a minimum
In order to have "minimum" on objective grounds, the tools used to develop this project were adopted based on the following two premises:
- A tool should not influence or limit any design/architecture decision (e.g. a particular folder structure).
- A tool should not jump start any given requirement (e.g. [API wrappers](https://www.npmjs.com/search?q=tvmaze), ready-made UI components).

#### A note on [Vite](https://vitejs.dev/)
Although Vite can give one a Vue.js application running in a matter of seconds, the main point of its adoption was to use the time that would otherwise be spent on setting up the development environment on addressing the requirements.

Going back in Git history, one may notice that a good deal of the business logic was implemented before Vue.js started being used, and Jest was the test runner. However, as the need for a view layer came along and Typescript was already in the mix, running the application in a browser would require a build step and an HTTP server solution. Hence, Vite was adopted. Also, since Jest and Vitest provide basically the same API, the latter taking the upper hand performance-wise, Vitest was kept.

It's worth emphasizing that going with Vite did not influence or limit any design or architecture decision. The `tsconfig` files and the `vite.config` file as well, for example, have been modified and unnecessary scaffolding removed. About jump starting requirements, Vite might actually have helped with the navigation part. But the router configuration in such a simple application is completely generic, and having done it manually would likely have yielded the exact same outcome with no significant time saving.

### Test-Driven Development (TDD)
The codebase is thoroughly unit-tested as TDD was adopted in order to develop this project, especially the more logical and non-view related parts.

### Domain-Driven Development (DDD)
One may pull the "Over-engineering" card on layering out the business logic of the view components. However, even the simplest of the front-end projects may benefit from DDD:
- By establishing one single possible (transitive) dependency chain (`infrastructure` (`infra`) depends on `application`, and `application` on `domain`), layers can be individually tested based on inputs and outputs. For instance, there is no risk of messing up core businees logic while working on a view component.
- [The consumed API](https://www.tvmaze.com/api) lives under another jurisdiction, hence its integrity cannot be guaranteed. Therefore, an [anti-corruption layer](https://learn.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer) is necessary to ensure internal consistency. With that, there is no doubt that a "show" will always be a [`Show`](./domain/show/entity.ts) within this architecture.

Other than that, one major advantage of this approach should be to retain functionality over major refactors and technology shifts. And that's not to say moving away from Vue.js. The framework is already in it's third version, there might be more to come, and transitioning can be less of a headache with DDD. While keeping things agnostic closer to the domain, the changes in the view layer can be carried out more easily.

Of course, plumbing code is entailed when such a route is taken. For example, procedural navigation is enforced to cope with navigation events, which means that the `router-link` component can't be used as such.

A major shortcoming from that is that the `push` method from the router for procedural navigtaion forces a full page reload, which seems bad but might not be a deal-breaker at the end of the day, given the aforementioned reasons. Neither should this be looked at as a subversion of best practices as Vue.js itself heavily relies on event handling.

### Typescript
It's true that Vue.js allows no-build applications, meaning that Typescript is no hard requirement strictly speaking. However, the `domain` layer, for instance, is mostly about some types and interfaces, which would be unattainable without Typescript. Additionally, Typescript can settle an agreement layer between developers, which is much need especially in large projects and is probably why ABN Amro has it as a requirement for the vacancy this project is meant for.

### Styling approach
Although a mighty solution like [Tailwind](https://tailwindcss.com/) would probably have cleared out the styling-related requirements much faster than the adopted one, it would probably not be in line with any of the aforementioned tool adoption criteria, not to mention its large footprint. Neither would it make evident the commoner hurdles of dealing with CSS (e.g. stacking contexts, layout modules, etc.). Therefore, class-based styling in single-file components (SFC) was chosen for the strategy-basis. The outcome is truly verbose though.

Based on that, [Open Props](https://open-props.style/) were adopted to somehow fill in for a missing UX designer or Design System. The option of [PostCSS](https://postcss.org/) for the CSS flavor is just enough to allow incremental addition of features to make working with _quasi_-vanilla CSS "bearable". For example, it allows the use of CSS nesting today, even though [it's still a working draft.](https://caniuse.com/css-nesting)

### No dedicated state management system
A dedicated state management system, although usual in this kind of application, has purposefully been left out of the equation as it has nothing that the intrinsic reactive system of Vue.JS can't handle. 

Were it a requirement, though, the search component could potentially benefit from it, as it has a relatively complex behavior compared to the others. [Pinia](https://pinia.vuejs.org/) should be the system to adopt as not only is it maintained by those who maintain Vue.js, but also it's oddly intuitive.

### Vue.js style guide
If there was anything to bias the design decisions made in this project, that would be the naming conventions and the preconized folder structure by the [official Vue.js style guide](https://vuejs.org/style-guide/). I tried to follow such practices as close as possible in order to ease whoever Vue.js developer into this project.

Or I have done so only inside the infrastructure (`infra`) folder, where everything Vue.js lives. I can't help but point out that some of those alleged best practices are usually situational and tend to ignore best practices of software engineering in general.

For example, some claims based on IDE browsing fall flat for command-line-based environments and diffing mechanisms. Having test files separated from the files they are meant to test not only adds steps to test-driven development, but also renders module management error prone. Think of when a file is renamed/moved/deleted but its counterpart test file is left behind. 

All in all, this style guide might work for someone trying their hand at Vue.js, but from experience I would suggest a team to swear by their own thoroughly crafted conventions and agreements.
