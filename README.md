# üìΩÔ∏è ABN Amro Tube 

A Vue.js-based application to browse TV shows from http://www.tvmaze.com/api .

## Requirements *
- Node.js (v21.6.1)
- npm (v10.2.4)

\* A warning will be issued when installing the project in lower versions, but it might still work.

## Running the application
- Install the project (`npm install`)
- Build the application (`npm run build`)
- Run the application (`npm run preview`)
- Follow the link output in the console

Obs.: [This project was bootstrapped with Vite](#keeping-scaffolding-boilerplate-templates-plugins-etc-to-a-minimum), so those steps should look familiar to those used to the tool.

### Running the unit tests
Once the project is installed (`npm install`), the command `npm test` can be issued to run the unit tests.

### No live environment
Since the ABN Amro trademark is used in this project, there is no live environment where this project is running. Were that a requirement, one just had to place the contents in the `dist` folder, generated by the `build` script, in an HTTP server.

## Development notes

### Keeping scaffolding, boilerplate templates, plugins, etc. to a minimum
In order to have "minimum" on objective grounds, the tools used to develop this project were adopted based on the following two premises:
- A tool should not influence or limit any design/architecture decision (e.g. a particular folder structure).
- A tool should not jump start any given requirement (e.g. [API wrappers](https://www.npmjs.com/search?q=tvmaze), ready-made UI components).

#### A note on [Vite](https://vitejs.dev/)
Although Vite can give one a Vue.js application running in a matter of seconds, the main point of its adoption was to use the time that would otherwise be spent on setting up the development environment on addressing the requirements.

Going back in Git history, one may notice that a good deal of the business logic was implemented before Vue.js started being used, and Jest was the test runner. However, as the need for a view layer came along and Typescript was already in the mix, running the application in a browser would require a build step and an HTTP server solution. Hence, Vite was adopted. Also, since Jest and Vitest provide basically the same API, the latter taking the upper hand performance-wise, Vitest was kept.

It's worth emphasizing that going with Vite did not influence or limit any design or architecture decision. The `tsconfig` files and the `vite.config` file as well, for example, have been modified and unnecessary scaffolding removed. About jump starting requirements, Vite might actually have helped with the navigation part. But the router configuration in such a simple application is completely generic, and having done it manually would likely have yielded the exact same outcome with no significant time saving.

### Test-Driven Development (TDD)
The codebase is thoroughly unit-tested as TDD was adopted in order to develop this project, especially the more logical and non-view related parts.

### Domain-Driven Development (DDD)
One may pull the "Over-engineering" card on layering out the business logic of the view components. However, even the simplest of the front-end projects may benefit from DDD:
- By establishing one single possible (transitive) dependency chain (`infrastructure` depends on `application`, and `application` on `domain`), layers can be individually tested based on inputs and outputs. For instance, there is no risk of messing up core businees logic while working on a view component.
- [The consumed API](https://www.tvmaze.com/api) lives under another jurisdiction, hence its integrity cannot be guaranteed. Therefore, an [anti-corruption layer](https://learn.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer) is necessary to ensure internal consistency. With that, there is no doubt that a "show" will always be a [`Show`](./domain/show/entity.ts) within this architecture.

Other than that, one major advantage of this approach should be to retain functionality over major refactors and technology shifts. And that's not to say moving away from Vue.js. The framework is already in it's third version, there might be more to come, and transitioning can be less of a headache with DDD. While keeping things agnostic closer to the domain, the changes in the view layer can be carried out more easily.

Of course, plumbing code is entailed when such a route is taken. For example, procedural navigation is enforced to cope with navigation events, which means that the `router-link` component can't be used as such. However, this is no subversion of Vue.js best practices, as they rely heavily on event handling and Vue Router already packs a procedural navigation solution.

### Typescript
It's true that Vue.js allows no-build applications, meaning that Typescript is no hard requirement strictly speaking. However, the `domain` layer, for instance, is mostly about some types and interfaces, which would be unattainable without Typescript. Additionally, Typescript can settle an agreement layer between developers, which is much need especially in large projects and is probably why ABN Amro has it as a requirement for the vacancy this project is meant for.

### Styling approach
Although a mighty solution like [Tailwind](https://tailwindcss.com/) would probably have cleared out the styling-related requirements much faster than the adopted one, it would probably not be in line with any of the aforementioned tool adoption criteria, not to mention its large footprint. Neither would it make evident the commoner hurdles of dealing with CSS (e.g. stacking contexts, layout modules, etc.). Therefore, class-based styling in single-file components (SFC) was chosen for the strategy-basis. The outcome is truly verbose though.

Based on that, [Open Props](https://open-props.style/) were adopted to somehow fill in for a missing UX designer or Design System. The option of [PostCSS](https://postcss.org/) for the CSS flavor is just enough to allow incremental addition of features to make working with _quasi_-vanilla CSS "bearable". For example, it allows the use of CSS nesting today, even though [it's still a working draft.](https://caniuse.com/css-nesting)


### Vue.js style guide
If there was anything to bias the design decisions made in this project, that would be the naming conventions and the preconized folder structure by the [official Vue.js style guide](https://vuejs.org/style-guide/). I tried to follow such practices as close as possible in order to ease whoever Vue.js developer into this project.

However, I can't help but express that I mostly disagree with said practices. They are usually situational and tend to ignore best practices of software development in general.

For example, some claims based on IDE browsing fall flat for command-line-based environments and diffing mechanisms. Having test files separated from the files they are meant to test not only adds steps to test-driven development, but also renders module management error prone. Think of when a file is renamed/moved/deleted but its counterpart test file is left behind. 

Lastly, I would like to tell a related episode that actually happened to myself to give my own claims some grounding. I once checked a file with the wrong casing in the version control system. Later on, I changed the file and renamed it accordingly, but the server was case-insensitive and refused to serve the right version. It's true that the style guide acknowledges this scenario, but in my humble opinion it should not be prescriptive about it in the first place.

All in all, this style guide might work for someone trying their hand at Vue.js, but from experience I would suggest a team to swear by their own thoroughly crafted conventions and agreements.
